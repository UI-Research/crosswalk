% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crosswalk_data.R
\name{crosswalk_data}
\alias{crosswalk_data}
\title{Apply a Crosswalk to Transform Data}
\usage{
crosswalk_data(
  data,
  crosswalk,
  geoid_column = "geoid",
  count_columns = NULL,
  non_count_columns = NULL,
  return_intermediate = FALSE
)
}
\arguments{
\item{data}{A data frame or tibble containing the data to crosswalk.}

\item{crosswalk}{The output from \code{get_crosswalk()} - a list containing:
\describe{
\item{crosswalks}{A named list of crosswalk tibbles (step_1, step_2, etc.)}
\item{plan}{The crosswalk plan}
\item{message}{Description of the crosswalk chain}
}
Alternatively, a single crosswalk tibble can be provided for backwards
compatibility.}

\item{geoid_column}{Character. The name of the column in \code{data} containing
the source geography identifiers (GEOIDs). Default is "geoid".}

\item{count_columns}{Character vector or NULL. Column names in \code{data} that represent
count variables. These will be summed after multiplying by the allocation factor.
If NULL (default), automatically detects columns with the prefix "count_".}

\item{non_count_columns}{Character vector or NULL. Column names in \code{data} that represent
mean, median, percentage, and ratio variables. These will be calculated as weighted
means using the allocation factor as weights. If NULL (default), automatically
detects columns with prefixes "mean_", "median_", "percent_", or "ratio_".}

\item{return_intermediate}{Logical. If TRUE and crosswalk has multiple steps,
returns a list containing both the final result and intermediate results
from each step. Default is FALSE, which returns only the final result.}
}
\value{
If \code{return_intermediate = FALSE} (default), a tibble with data summarized
to the final target geography.

If \code{return_intermediate = TRUE} and there are multiple crosswalk steps, a list with:
\describe{
\item{final}{The final crosswalked data}
\item{intermediate}{A named list of intermediate results (step_1, step_2, etc.)}
}

The returned tibble(s) include an attribute \code{crosswalk_metadata} from the
underlying crosswalk (access via \code{attr(result, "crosswalk_metadata")}).
}
\description{
Applies geographic crosswalk weights to transform data from a source geography
to a target geography. Accepts the output from \code{get_crosswalk()} and automatically
applies all crosswalk steps sequentially for multi-step transformations.
}
\details{
\strong{Count variables} (specified in \code{count_columns}) are interpolated by summing
the product of the value and the allocation factor across all source geographies
that overlap with each target geography.

\strong{Non-count variables} (specified in \code{non_count_columns}) are interpolated using
a weighted mean, with the allocation factor serving as the weight.

\strong{Automatic column detection}: If \code{count_columns} and \code{non_count_columns} are
both NULL, the function will automatically detect columns based on naming prefixes:
\itemize{
\item Columns starting with "count_" are treated as count variables
\item Columns starting with "mean_", "median_", "percent_", or "ratio_" are treated
as non-count variables
}

\strong{Multi-step crosswalks}: When \code{get_crosswalk()} returns multiple crosswalks
(for transformations that change both geography and year), this function
automatically applies them in sequence.
}
\examples{
\dontrun{
# Single-step crosswalk
crosswalk <- get_crosswalk(
  source_geography = "tract",
  target_geography = "zcta",
  weight = "population")

result <- crosswalk_data(
  data = my_tract_data,
  crosswalk = crosswalk,
  geoid_column = "tract_geoid",
  count_columns = c("count_population", "count_housing_units"))

# Multi-step crosswalk (geography + year change)
crosswalk <- get_crosswalk(
  source_geography = "tract",
  target_geography = "zcta",
  source_year = 2010,
  target_year = 2020,
  weight = "population")

# Automatically applies both steps
result <- crosswalk_data(
  data = my_data,
  crosswalk = crosswalk,
  geoid_column = "tract_geoid",
  count_columns = "count_population")

# To get intermediate results
result <- crosswalk_data(
  data = my_data,
  crosswalk = crosswalk,
  geoid_column = "tract_geoid",
  count_columns = "count_population",
  return_intermediate = TRUE)

# Access intermediate and final
result$intermediate$step_1  # After first crosswalk
result$final                # Final result
}
}
