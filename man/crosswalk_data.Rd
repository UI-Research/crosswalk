% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crosswalk_data.R
\name{crosswalk_data}
\alias{crosswalk_data}
\title{Interpolate data using a crosswalk(s)}
\usage{
crosswalk_data(
  data,
  crosswalk = NULL,
  source_geography = NULL,
  target_geography = NULL,
  source_year = NULL,
  target_year = NULL,
  weight = "population",
  cache = NULL,
  geoid_column = "source_geoid",
  count_columns = NULL,
  non_count_columns = NULL,
  return_intermediate = FALSE,
  show_join_quality = TRUE,
  silent = getOption("crosswalk.silent", FALSE)
)
}
\arguments{
\item{data}{A data frame or tibble containing the data to crosswalk.}

\item{crosswalk}{The output from \code{get_crosswalk()} - a list containing:
\describe{
\item{crosswalks}{A named list of crosswalk tibbles (step_1, step_2, etc.)}
\item{plan}{The crosswalk plan}
\item{message}{Description of the crosswalk chain}
}
Alternatively, a single crosswalk tibble can be provided for backwards
compatibility. If NULL, the crosswalk will be fetched using \code{source_geography}
and \code{target_geography} parameters.}

\item{source_geography}{Character or NULL. Source geography name. Required if
\code{crosswalk} is NULL. One of c("block", "block group", "tract", "place",
"county", "urban_area", "zcta", "puma", "cd118", "cd119",
"core_based_statistical_area").}

\item{target_geography}{Character or NULL. Target geography name. Required if
\code{crosswalk} is NULL. Same options as \code{source_geography}.}

\item{source_year}{Numeric or NULL. Year of the source geography. If NULL and
crosswalk is being fetched, uses same-year crosswalk via Geocorr.}

\item{target_year}{Numeric or NULL. Year of the target geography. If NULL and
crosswalk is being fetched, uses same-year crosswalk via Geocorr.}

\item{weight}{Character. Weighting variable for Geocorr crosswalks when fetching.
One of c("population", "housing", "land"). Default is "population".}

\item{cache}{Directory path or NULL. Where to cache fetched crosswalks. If NULL
(default), crosswalk is fetched but not saved to disk.}

\item{geoid_column}{Character. The name of the column in \code{data} containing
the source geography identifiers (GEOIDs). Default is "source_geoid".}

\item{count_columns}{Character vector or NULL. Column names in \code{data} that represent
count variables. These will be summed after multiplying by the allocation factor.
If NULL (default), automatically detects columns with the prefix "count_".}

\item{non_count_columns}{Character vector or NULL. Column names in \code{data} that represent
mean, median, percentage, and ratio variables. These will be calculated as weighted
means using the allocation factor as weights. If NULL (default), automatically
detects columns with prefixes "mean_", "median_", "percent_", or "ratio_".}

\item{return_intermediate}{Logical. If TRUE and crosswalk has multiple steps,
returns a list containing both the final result and intermediate results
from each step. Default is FALSE, which returns only the final result.}

\item{show_join_quality}{Logical. If TRUE (default), prints diagnostic messages
about join quality, including the number of data rows not matching the crosswalk
and vice versa. For state-nested geographies (tract, county, block group, etc.),
also reports state-level concentration of unmatched rows. Set to FALSE to
suppress these messages. Automatically suppressed when \code{silent = TRUE}.}

\item{silent}{Logical. If \code{TRUE}, suppresses all informational messages and
warnings, including join quality diagnostics regardless of \code{show_join_quality}.
Defaults to \code{getOption("crosswalk.silent", FALSE)}. Set
\code{options(crosswalk.silent = TRUE)} to silence all calls by default.}
}
\value{
If \code{return_intermediate = FALSE} (default), a tibble with data summarized
to the final target geography.

If \code{return_intermediate = TRUE} and there are multiple crosswalk steps, a list with:
\describe{
\item{final}{The final crosswalked data}
\item{intermediate}{A named list of intermediate results (step_1, step_2, etc.)}
}

The returned tibble(s) include an attribute \code{crosswalk_metadata} from the
underlying crosswalk (access via \code{attr(result, "crosswalk_metadata")}).
}
\description{
Applies geographic crosswalk weights to transform data from a source geography
to a target geography. Can either accept a pre-fetched crosswalk from
\code{get_crosswalk()} or fetch the crosswalk automatically using the provided
geography and year parameters.
}
\details{
\strong{Two usage patterns}:
\enumerate{
\item \strong{Pre-fetched crosswalk}: Pass the output of \code{get_crosswalk()} to the
\code{crosswalk} parameter. Useful when you want to inspect or reuse the crosswalk.
\item \strong{Direct crosswalking}: Pass \code{source_geography} and \code{target_geography}
(and optionally \code{source_year}, \code{target_year}, \code{weight}, \code{cache}) and the
crosswalk will be fetched automatically. Useful for one-off transformations.
}

\strong{Count variables} (specified in \code{count_columns}) are interpolated by summing
the product of the value and the allocation factor across all source geographies
that overlap with each target geography.

\strong{Non-count variables} (specified in \code{non_count_columns}) are interpolated using
a weighted mean, with the allocation factor serving as the weight.

\strong{Automatic column detection}: If \code{count_columns} and \code{non_count_columns} are
both NULL, the function will automatically detect columns based on naming prefixes:
\itemize{
\item Columns starting with "count_" are treated as count variables
\item Columns starting with "mean_", "median_", "percent_", or "ratio_" are treated
as non-count variables
}

\strong{Other columns}: Columns that are not the geoid column, count columns, or
non-count columns (e.g., metadata like \code{data_year}) are preserved by taking
the first non-missing value within each target geography group. If all values
are missing, NA is returned.

\strong{Multi-step crosswalks}: When \code{get_crosswalk()} returns multiple crosswalks
(for transformations that change both geography and year), this function
automatically applies them in sequence.
}
\examples{
\dontrun{
# Option 1: Pre-fetched crosswalk
crosswalk <- get_crosswalk(
  source_geography = "tract",
  target_geography = "zcta",
  weight = "population")

result <- crosswalk_data(
  data = my_tract_data,
  crosswalk = crosswalk,
  geoid_column = "tract_geoid",
  count_columns = c("count_population", "count_housing_units"))

# Option 2: Direct crosswalking (crosswalk fetched automatically)
result <- crosswalk_data(
  data = my_tract_data,
  source_geography = "tract",
  target_geography = "zcta",
  weight = "population",
  geoid_column = "tract_geoid",
  count_columns = c("count_population", "count_housing_units"))

# Direct crosswalking with year change
result <- crosswalk_data(
  data = my_data,
  source_geography = "tract",
  target_geography = "zcta",
  source_year = 2010,
  target_year = 2020,
  weight = "population",
  geoid_column = "tract_geoid",
  count_columns = "count_population")

# Pre-fetched crosswalk with intermediate results
crosswalk <- get_crosswalk(
  source_geography = "tract",
  target_geography = "zcta",
  source_year = 2010,
  target_year = 2020,
  weight = "population")

result <- crosswalk_data(
  data = my_data,
  crosswalk = crosswalk,
  geoid_column = "tract_geoid",
  count_columns = "count_population",
  return_intermediate = TRUE)

# Access intermediate and final
result$intermediate$step_1  # After first crosswalk
result$final                # Final result
}
}
